# -*- coding: utf-8 -*-
"""Empuxo.ipynb

Automatically generated by Colaboratory.

Código Base
    https://colab.research.google.com/drive/1bsX5PWVkDug-rEGKFAq-b_aMmZ1GeTkg

Os códigos foram tirados do Projeto proptools: Rocket Propulsion Design Tools.

Proptools é um pacote do Python para projetar sistemas de propulsão de foguetes.
O software foi escrito por Matthew Vernacchia, um pesquisador graduado no departamento de Aeronáutica e Astronáutica do MIT.

A maioria das equações foram tiradas do livro "Modern Engineering for Design of Liquid-Propellant Rocket Engines", de Dieter Huzel e David Huang, e do "Rocket Propulsion Elements", de George Sutton e Oscar Biblarz.

Mais informações do projeto estão no site:
https://proptools.readthedocs.io/en/latest/nozzle_tutorial.html#thrust

Os códigos completos estão no GitHub:
https://github.com/mvernacc/proptools
"""

#pip install proptools-rocket

import fire
from matplotlib import pyplot as plt
import numpy as np
from proptools import solid
from proptools import nozzle
from scipy.optimize import fsolve
from scipy.integrate import cumtrapz

# Tratamento de Erros
def __notAccept__(num, msg):
    num = input(f'Valor invalido para {msg}. Tente novamente: ')
    return __is_valid__(num, msg)


def __is_valid__(num, msg):
    try:
        float(num) > 0
        return float(num)

    except:
        pass

    return __notAccept__(num, msg)


# Propriedades do Combustível e do Gás de Exaustão
R_univ = 8.314                   # Constante universal dos gase [unidade: joule kelvin**-1 mole**-1]
gamma = 1.1332                   # Razão da capacidade de calor de exaustão [unidade: adimensional].
m_molar = 20e-3                  # Massa molar dos gases de escape [unidade: kilograma mole**-1].
T_c = 1750.                      # Temperatura do combustível [unidade: kelvin].
rho_solid = 1792.7               # Densidade do combustível sólido [unidade: kilograma metro**-3].
n = 0.5                          # Expoente da taxa de queima do combustível [unidade: adimensional].
a = 3.19e-3 * (8.260e6)**(-n)    # Coeficiente da taxa de queima, sendo que o combustível
                                 # queima a 3.19 mm s**-1 a 8.260 MPa [unidade: metro segundo**-1 pascal**-n].

# Funções Essenciais
def __TaxaExpansao__(p_c, p_e, gamma):
    """Expressão da taxa de expansão em função da pressão de saída (Pe).
    Refer: Rocket Propulsion Elements, 8th Edition, Equation 3-25
    Argumentos:
        p_c (escalar):Pressão da câmara [unidade: pascal].
        p_e (escalar): Pressão da saída do bucal [unidade: pascal].
        gamma (escalar): Razão da capacidade de calor de exaustão [unidade: adimensional].
    Retorna:
        Escalar: Taxa de expansão (A_e / A_t) [unidade: adimensional]
    """
    AtAe = ((gamma + 1) / 2)**(1 / (gamma - 1)) \
        * (p_e / p_c)**(1 / gamma) \
        * ((gamma + 1) / (gamma - 1)*( 1 - (p_e / p_c)**((gamma -1) / gamma)))**0.5
    AeAt = 1/AtAe
    return AeAt

def __RazaoPressoes__(AeAt, gamma):
    """Determina a razão entre a pressão de saída e a pressão na câmara (Pe/Pc) a partir da taxa de expansão (Ae/At). 

    Referência: Rocket Propulsion Elements, 8th Edition, Equation 3-25
    Argumentos:
        AeAt (escalar): Taxa de expansão (A_e / A_t) [unidade: adimensional].
        gamma (escalar): Razão da capacidade de calor de exaustão [unidade: adimensional].
    Returna:
        Escalar: Razão das pressões (Pe/Pc) [unidade: adimensional].
    """
    PePc = fsolve(lambda x: AeAt - __TaxaExpansao__(1., x, gamma), x0=1e-3 / AeAt)[0]
    assert PePc < 1
    return PePc


def __thrust_coef__(p_c, p_e, gamma, p_a=None, er=None):
    if (p_a is None and er is not None) or (er is None and p_a is not None):
        raise ValueError('Both p_a and er must be provided.')
    C_F = (2 * gamma**2 / (gamma - 1) \
        * (2 / (gamma + 1))**((gamma + 1) / (gamma - 1)) \
        * (1 - (p_e / p_c)**((gamma - 1) / gamma))
          )**0.5
    if p_a is not None and er is not None:
        C_F += er * (p_e - p_a) / p_c
    return C_F


def __graphic__(t, p_c, F):
    # Plot resultadoss.
    ax1 = plt.subplot(2, 1, 1)
    plt.plot(t, p_c * 1e-6)
    plt.ylabel('Chamber pressure [MPa]')

    ax2 = plt.subplot(2, 1, 2)
    plt.plot(t, F * 1e-3)
    plt.ylabel('Thrust, sea level [kN]')
    plt.xlabel('Time [s]')
    plt.setp(ax1.get_xticklabels(), visible=False)

    plt.tight_layout()
    plt.subplots_adjust(hspace=0)
    return plt.show()


## main
def empuxo(r_in = 0.015, r_ex = 0.044, L = 1.10, D_t = 0.00708):

    ### Geometria do Grão (cilíndrico com porte circular)
    r_in = __is_valid__(r_in, 'raio interno') # Raio interno do grão [unidade: metro].
    r_ex = __is_valid__(r_ex, 'raio externo') # Raio externo do grão [unidade: metro].
    L = __is_valid__(L, 'comprimento') # Comprimento do grão [unidade: metro].

    ### Geometria do Bucal
    D_t = __is_valid__(D_t, 'diametro da garganta') # Diâmetro da garganta [unidade: metro]
    A_t = np.pi*((D_t)**2) # Área da garganta [unidade: metro**2]
    A_e = 3.94e-5 # Área de saída da garganta [unidade: metro**2].

    ### Área de queima do combustível
    # Evolução da área de combustão
    x = np.linspace(0, r_ex - r_in)    # Distância em relação ao menor raio em direção ao maior raio, dividido em 50 segmentos [unidade: metro].
    A_b = 2 * np.pi * (r_in + x) * L   # Área do combustivel sendo queimada por segmento [unidade: metro**2].
    K = A_b / A_t     # Razão da Área de Combustão (A_b) e Área da garganta (A_t)

    ### Velocidade característica (c*)
    c = nozzle.c_star(gamma, m_molar, T_c)

    ### Cálculo da Pressão na câmara (Pc)
    p_c = solid.chamber_pressure(A_b / A_t, a, n, rho_solid, c) # [unidade: pascal]


    # Taxa de queima (r)
    r = a * p_c**n

    # Pressão de saída
    p_e = p_c * __RazaoPressoes__(A_e / A_t, gamma) #[unidade: pascal]

    # Força de Empuxo
    p_a = 101325    # Pressão do ambiente [unidade: pascal]
    F = A_t * p_c * __thrust_coef__(p_c, p_e, gamma, p_a, A_e / A_t)   # Força de empuxo [unidade: Newton]
#F = nozzle.thrust(A_t, p_c, p_e, gamma, p_a, A_e / A_t)

    # Tempo
    t = cumtrapz(1 / r, x, initial=0)  # [unidade: segundos]

    #t, p_c, F = solid.thrust_curve(A_b, x, A_t, A_e, p_a, a, n, rho_solid, c_star, gamma)

    return __graphic__(t, p_c, F)


fire.Fire(empuxo)